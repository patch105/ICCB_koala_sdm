---
title: "ICCB Species distribution modelling and validation"
author: "Scott Forrest and Charlotte Patterson"
date: "`r Sys.Date()`"
execute: 
  cache: false
# bibliography: references.bib
toc: true
number-sections: false
format: 
  html:
    self-contained: true
    code-fold: show
    code-tools: true
    df-print: paged
    code-line-numbers: true
    code-overflow: scroll
    fig-format: png
    fig-dpi: 300
  pdf:
    geometry: 
      - top=30mm
      - left=30mm
editor:
  source
abstract: |
  In this script we are fitting species distribution models to the data of koalas (Phascolarctos cinereus) in the South-East Queensland (SEQ) region under current environmental conditions, which we will predict into future environmental conditions. 
---

## Import packages

```{r}

library(dplyr)
library(purrr)
library(ggplot2)
library(terra)
library(sf)
library(predicts)
library(blockCV)

```

## Sampling bias

```{r}

ggplot() +
  geom_sf(data = SEQ_extent, fill = "purple3", alpha = 0.5, color = "black", size = 0.2) +
  geom_sf(data = koala_occ_sf,                           # Add koala presence locations
          aes(geometry = geometry),
             color = "blue", size = 0.5) +               # Add points for occurrences
  ggtitle("Koala occurrences in South East Queensland") +      # Add title
  theme_bw()

```

# Human population density

https://qldspatial.information.qld.gov.au/catalogue/custom/detail.page?fid={36DBF62A-76E4-4BFA-A04A-E747401C4C09}

Some relevant details from the Metadata for this dataset: 

POPULATION - The population (number of persons) indicated by the ABS Census figures that exist for this locality. This field will no longer be updated as of the 01/03/2016 due to changes in the source data from ABS data.

```{r}

pop.centre <- st_read("Data/Environmental_variables/Population_centres.shp")
pop.centre <- st_transform(pop.centre, crs = st_crs(SEQ_extent)) # Transform to match SEQ_extent

head(pop.centre)

# Trim to South East Queensland
pop.centre <- vect(pop.centre)

pop.centre <- mask(pop.centre, SEQ_extent.vect) %>% 
  filter(population != 0)

ggplot() +
  geom_sf(data = SEQ_extent, color = "black", size = 0.2) +
  geom_sf(data = pop.centre, color = "purple3", aes(size = population), alpha = 0.5) +
  theme_minimal() +
  labs(title = "Population density in cities and towns in SEQ")

```

```{r}

ggplot() +
  geom_sf(data = SEQ_extent, color = "black", size = 0.2) +
  geom_sf(data = koala_occ_sf,                           # Add koala presence locations
          aes(geometry = geometry),
             color = "blue", size = 0.5, alpha = 0.1) + 
  geom_sf(data = pop.centre, color = "purple3", aes(size = population)) +
  theme_minimal() +
  labs(title = "Population density in cities and towns in SEQ")


```


# Calculate distance to main centres

```{r}

dist_centres <- terra::distance(ext.rast, pop.centre)
dist_centres <- mask(dist_centres, ext.rast, maskvalue = NA)

ggplot() +
  geom_spatraster(data = dist_centres) +
  scale_fill_viridis_c() +
   theme_minimal() +
  labs(title = "Distance to cities and towns SEQ")

```


For city accessibility you can get a publicly available version using the following code:

```{r}

url <- 'https://figshare.com/ndownloader/files/14189843'

file <- 'Data/Environmental_variables/accessibility.tif'  # assuming you are in an R project folder that contains a “data” subfolder

options(timeout = 1500) # increased max downloading time to 25 min

download.file(url, file)

accessibility_rast <- rast(file)

NAflag(accessibility_rast) <- 65535 # reclass 65535 (water) as NA

subsection <- ext(112, 155, -45, -10) # extent to crop to include Australia only [here you can use your own area]

accessibility_rast <- crop(accessibility_rast, SEQ_extent)

# transform it by using square root to get a better model fit

accessibility_rast <- sqrt(accessibility_rast)

```


The human population density was taken from:
https://www.abs.gov.au/AUSSTATS/abs@.nsf/DetailsPage/1270.0.55.0072011?OpenDocument


```{r}

library(sampbias)


```

## Load koala presences and background points

They are loaded as spatvectors, but we also want them as dataframes for model input requirements.

```{r}

koala_occ <- vect("Data/Biological_records/SEQ_koala_occurrences.shp")
background <- vect("Data/Biological_records/background_points_50k_random.shp")

# Make a dataframe of just x, y and presence
koala_occ_df <- koala_occ %>% 
  as.data.frame(geom = "XY") %>% 
  dplyr::select(x,y) %>% 
  mutate(Presence = 1)

head(koala_occ_df)

background_df <- background %>% 
  as.data.frame(geom = "XY") %>% 
  dplyr::select(x,y) %>% 
  mutate(Presence = 0)

head(background_df)

# Combine to one
pr_bg <- rbind(koala_occ_df, background_df)

```

## Load environmental covariates

```{r}



```

## Extract environmental covariate values from presence and background locations (training locations)

```{r}

train_PB_covs <- terra::extract(covs, pr_bg[,c("x", "y")], xy = T)
train_PB_covs <- cbind(train_PB_covs, pr_bg["Presence"])

# Remove rows where there's values missing from at least one covariate

print(paste0("RECORDS FROM ", nrow(train_PB_covs) - sum(complete.cases(train_PB_covs)), " ROWS IN TRAINING DATA REMOVED DUE TO MISSING COVARIATE VALUES"))

train_PB_covs <- train_PB_covs[complete.cases(train_PB_covs), ] 
train_PB_covs <- dplyr::select(train_PB_covs, -ID)

```

## Define environmental covariate values for prediction under *current* conditions

```{r}

pred_cur_covs <- as.data.frame(covs, xy = T)

print(paste0("RECORDS FROM ", nrow(pred_cur_covs) - sum(complete.cases(pred_cur_covs)), " ROWS IN PREDICTION DATA REMOVED DUE TO MISSING COVARIATE VALUES"))

# Remove rows with NA in any covariates
pred_cur_covs <- pred_cur_covs[complete.cases(pred_cur_covs), ]
pred_cur_covs <- dplyr::select(pred_cur_covs, -ID)

```


## Maxent

```{r}

# Make a folder to save outputs
  
dir.create("Outputs/Maxent_outputs", showWarnings = F)


```


```{r}

maxent.mod <- NULL

maxent.mod <- predicts::MaxEnt(x = train_PB_covs[, cov_names],
                               p = train_PB_covs[["Presence"]],
                               removeDuplicates = FALSE,
                               path = "Outputs/Maxent_outputs",
                               args = c("nothreshold"))

maxent.mod <- dismo::maxent(x = train_PB_covs[, cov_names],
                              p = train_PB_covs[["Presence"]],
                              removeDuplicates = FALSE,
                              path = "Outputs/Maxent_outputs",
                              args = c("nothreshold"))
  
  
```



## Model evaluation with spatial block cross-validation

```{r}

# Convert training data to sf
train_PB_sf <- st_as_sf(train_PB_covs[, c("x", "y", "Presence")], coords = c("x", "y"), crs = "EPSG:3031")

# Generate spatial blocks
spblock <- cv_spatial(x = train_PB_sf, 
                      column = "Presence",
                      r = NULL,
                      size = 1000, # Size of the blocks in metres
                      k = 5,
                      hexagon = TRUE,
                      selection = "random",
                      iteration = 100, # to find evenly-dispersed folds
                      biomod2 = FALSE)

cv_plot(cv = spblock,
        x = train_PB_sf,
        points_alpha = 0.5,
        nrow = 2)


```



```{r}

# Testing set prediction
  pred_test.mxt <- dismo::predict(maxent.mod, test_PB_covs_scv, args = "doclamp=false")
  pred_test.mxt <- cbind(test_PB_covs_scv, pred_test.mxt)
  colnames(pred_test.mxt)[grepl("pred", colnames(pred_test.mxt))] <- "pred"
  
  # Make an evaluation function
  evaluate_prediction <- function(x){
  
  ROC = precrec::auc(precrec::evalmod(scores = x$pred, labels = x$Presence))[1,4]
  PRG = prg::calc_auprg(prg::create_prg_curve(labels = x$Presence, pos_scores = x$pred))
  boyce = ecospat::ecospat.boyce(fit = x$pred, 
                                 obs = x$pred[which(x$Presence==1)], 
                                 nclass = 0, # Calculate continuous index
                                 method = "pearson",
                                 PEplot = T)[["cor"]]
  
  partialROC = kuenm::kuenm_proc(occ.test = x$pred[which(x$Presence==1)],
                                 model = x$pred,
                                 threshold = 80,   # Omission threshold (e.g., 80%)
                                 rand.percent = 50, # What percent of testing data for bootstrap
                                 iterations = 500)$pROC_summary[[1]]
  
  eval_df <- data.frame(ROC = ROC,
                        PRG = PRG,
                        boyce = boyce,
                        partialROC = partialROC) 

 return(eval_df)
  
}

  
  # Evaluate prediction on test set
  eval <- evaluate_prediction(pred_test.mxt)
  
  eval_df.mxt <- data.frame(group = group, 
                            fold = f, 
                            model = "MaxEnt", 
                            eval)

  # Current prediction
  pred_cur.mxt <- dismo::predict(maxent.mod, pred_cur_covs, args = "doclamp=false")
  pred_cur.mxt <- cbind(pred_cur_covs, pred_cur.mxt)
  colnames(pred_cur.mxt)[grepl("pred", colnames(pred_cur.mxt))] <- "pred"
  # pred_cur.rast <- rast(pred_cur[, c("x", "y", "pred")], type = "xyz", crs = "EPSG:3031")
  
  # Future prediction
  # pred_fut.mxt <- dismo::predict(maxent.mod, pred_fut_covs, args = "doclamp=false")
  
  # plet(pred.rast, "pred", tiles = "")
  # 
  # plet(pred.rast, "pred", tiles = "") %>% 
  #   points(background, col = "white", cex = 0.5, popup = T) %>% 
  #   points(bio.recordsVect, col = "red", cex = 0.5, popup = T)

```



## Re-running Maxent with spatial block cross validation

```{r}



```




## Define environmental covariate values for prediction under *future* conditions

```{r}

pred_fut_covs <- as.data.frame(covs, xy = T)

print(paste0("RECORDS FROM ", nrow(pred_fut_covs) - sum(complete.cases(pred_fut_covs)), " ROWS IN PREDICTION DATA REMOVED DUE TO MISSING COVARIATE VALUES"))

# Remove rows with NA in any covariates
pred_fut_covs <- pred_fut_covs[complete.cases(pred_fut_covs), ]
pred_fut_covs <- dplyr::select(pred_fut_covs, -ID)

```

## Test the environmental distance between current data and future conditions

```{r}

```


